# Copyright (c) 2025 Haoyu Li
# Released under the MIT License.
# See LICENSE file in the project root for details.

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys
import re
import ast
import traceback
from pathlib import Path
from typing import Dict, Any, List
import sqlglot
from sqlglot import parse_one
from sqlglot.optimizer import optimize
from sqlglot.expressions import And, Expression

# -----------------------------------------------------------------------------
# Path Configuration
# -----------------------------------------------------------------------------

root_dir = str(Path(__file__).parent.parent)
sys.path.extend(
    [
        root_dir,
        str(Path(root_dir) / "src"),
        str(Path(root_dir) / "util"),
    ]
)

# -----------------------------------------------------------------------------
# Local Imports
# -----------------------------------------------------------------------------

from param import get_dialect_param
from schema import get_schema
from log import log

# -----------------------------------------------------------------------------
# SQL Parsing Functions
# -----------------------------------------------------------------------------


def parse_table(table_expression: Expression) -> Dict[str, str]:
    """
    Extract table name and alias from a SQL table expression.

    Args:
        table_expression: sqlglot table expression

    Returns:
        Dict[str, str]: Table information with 'name' and 'alias' keys

    Raises:
        Exception: If parsing fails or table alias is missing
    """
    try:
        
        while table_expression.args.get("alias") is None:
            table_expression = table_expression.args.get("this")
            
        """
        Warning:
            We have to handle the case where the table is UNNEST("table") as _T_0("table")
            that generated by the parser.
        """

        try:
            table_name = table_expression.args.get("this").sql()
            alias_name = table_expression.args.get("alias").sql()
        except:
            table_name = table_expression.args.get("expressions")[0].sql()
            alias_name = table_expression.args.get("alias").args.get("columns")[0].sql()

        assert alias_name is not None, "Missing table alias"

        return {"name": table_name, "alias": alias_name}

    except Exception as e:
        traceback.print_exc()
        raise e


def parse_condition(condition: Expression) -> List[str]:
    """
    Parse SQL conditions into a list of condition strings.

    Args:
        condition: sqlglot condition expression

    Returns:
        List[str]: List of SQL condition strings
    
    Warning:
        1. The parser may give a NOT condition lower priority than OR, which potentially
        leads to incorrect parsing.
        For example, "NOT a OR b" is parsed as "NOT (a OR b)".
        We have raised the issue to sqlglot.
        
        2. The parser eliminates parentheses around a condition.
        For example, "(a AND b) OR c" is parsed as "OR{AND{a, b}, c}", not "OR{(AND{a, b}), c}".
        We haven't figure out how to fix this issue.
    """
    if isinstance(condition.this, And):
        return [condition.this.this.sql()] + parse_condition(condition.this.expression)
    result = condition.sql()

    return [result]


def get_parse(sql: str) -> Expression:
    """
    Get parsed SQL expression.
    """
    try:
        parse = parse_one(sql, read=get_dialect_param()["input"])
    except Exception as e:
        log("error.txt", str(e))
        raise e

    return parse


def parse_preview(row: str) -> Any:
    """
    Parse preview row string into Python objects.
    """
    try:
        # Handle decimal values
        row = re.sub(r"Decimal\(\'(-?\d+(\.\d+)?)\'\)", r"\1", row)

        # Handle dates
        row = re.sub(
            r"datetime\.date\((\d{4}), (\d{1,2}), (\d{1,2})\)",
            lambda m: f"{m.group(1)}{int(m.group(2)):02d}{int(m.group(3)):02d}",
            row,
            flags=re.IGNORECASE,
        )

        # Handle remaining decimals
        row = re.sub(r"Decimal\((.*)\)", r"\1", row)

        return ast.literal_eval(row)

    except Exception as e:
        traceback.print_exc()
        raise e


def get_optimize(sql: str) -> str:
    """
    Optimize SQL query using sqlglot and output formatted SQL.
    """
    sql = sqlglot.transpile(
        sql,
        read=get_dialect_param()["endpoint"],
        write=get_dialect_param()["endpoint"],
    )[0]

    from format import format

    return format(
        optimize(sql, get_schema(), dialect=get_dialect_param()["endpoint"]).sql()
    )
